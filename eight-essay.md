 [toc]

# C++

#### 比较虚函数和纯虚函数

虚函数使子类可以重写这个函数的实现，在基类与子类之间维护一个虚函数表，可以通过基类指针指向子类对象实现多态；纯虚函数为子类定义了一个接口，所有子类必须实现这个函数，含有纯虚函数的抽象类不能被实例化。

#### 虚函数实现原理

虚函数表+虚表指针。编译器为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向虚函数地址数组的指针，称为虚表指针，这种数组成为虚函数表，即，每个类使用一个虚函数表，每个类对象用一个虚表指针。

#### 虚函数表中，函数的位置怎么确定

虚函数表存放在全局区，编译时创建，每个类使用一个虚函数表，每个类对象用一个虚表指针，在调用虚函数时通过虚表指针指向的位置确定函数。

#### 虚表指针什么时候创建？使用虚函数需要注意什么？

虚表指针在对象构造时初始化。构造函数不能虚，析构函数必须虚，友元函数不能虚；如果要重新定义继承的方法，应确保与原来的原型完全相同；如果基类声明被重载了，则应该在派生类中重新定义所有的版本。

#### 简述继承、多态、封装

通过类体系实现封装，隐藏实现细节，使得代码模块化；通过子类实现继承，它可以使用基类的所有功能，并在此基础上进行扩展；通过虚函数表和虚表指针实现多态，允许基类指针指向子类对象。

#### 引用作为参数有什么特点？

传递引用与传递指针的效果一样，被调函数中对形参变量的操作都能直接改标目标对象；引用传递没有产生实参的副本，对于空间较大的参数传递能有效节省空间和提升效率；引用传递比指针更加简洁易用，更不容易出错。

#### 结构体和联合体的区别

结构体中每个变量享有单独的内存空间，大小为所有变量所占空间的总和（计算时需考虑字节对齐）；联合体中变量的内存共享，大小为最大变量所占的空间，改变一个变量的值可能影响其他变量。

#### malloc、free、new、delete的区别

1、定义：malloc和free是库函数，new和delete是操作符。

2、流程：malloc函数从堆上动态分配内存，new操作从自由存储区动态分配内存，经过operator new、指针类型转换、调用构造函数3个操作，其中operator new会调用malloc函数，operator new的实现细节决定自由存储区的具体位置。delete操作首先调用析构函数，然后通过operator delete调用free函数释放内存。

3、返回类型：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

4、异常处理：new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。要想new不抛异常，用new(std::nothrow)。

5、指定大小：使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

6、数组：new[]与delete[]来专门处理数组类型，malloc需要手动定义数组的大小。

#### static 变量存放在哪？

static变量存放在全局区（静态区），分为初始化区和未初始化区。

#### string的size和length的区别？

没有区别，标准库中的源代码完全一致。

#### main函数执行之前会执行什么？执行之后还能执行代码吗？

全局对象的构造会在main函数之前执行。可以，使用atexit()函数，注册一个在main函数之后执行的函数，先注册的后执行。

#### 类模版和函数模版。模版编译之后是怎样，不是类型不确定吗，如何编译？模版能在cpp文件中定义吗？

https://blog.csdn.net/OnafioO/article/details/86574746

https://blog.csdn.net/c_base_jin/article/details/72861789

#### 动态库与静态库的区别

静态库对函数库的链接是放在编译时期完成的，程序在运行时与函数库再无瓜葛，移植方便，但浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。动态库把对一些库函数的链接载入推迟到程序运行的时期，可以实现进程之间的资源共享，将一些程序升级变得简单，可以真正做到链接载入完全由程序员在程序代码中控制（显式调用）。

#### 静态编译与动态编译区别

静态编译就是在编译时，把所有模块都编译进可执行文件里，当启动这个可执行文件时，所有模块都被加载进来；动态编译是将应用程序需要的模块都编译成动态链接库，启动程序（初始化）时，这些模块不会被加载，运行时用到哪个模块就调用哪个。

#### 类的static变量和函数的static变量何时初始化？

类：定义时；函数：第一次调用时。

#### 函数调用原理。

参数入栈、函数跳转（call+jmp）、保护现场（指令指针压栈）、恢复现场。

https://blog.csdn.net/qq_35583007/article/details/78841904

#### ESP和EBP寄存器。

ESP：堆栈(Stack)指针寄存器，指向堆栈顶部；EBP：基址指针寄存器，指向当前堆栈底部

#### 类的成员函数、成员变量存储在哪？

<img src="/Users/wtb/Library/Application Support/typora-user-images/image-20230705113802717.png" alt="image-20230705113802717" style="zoom: 15%;" /> 

数据部分包括虚表指针

在类的定义时，类成员函数是被放在代码区，而类的静态成员变量在类定义时就已经在全局数据区分配了内存，因而它是属于类的。对于非静态成员变量，我们是在类的实例化过程中(构造对象)才在栈区或者堆区为其分配内存，是为每个对象生成一个拷贝，所以它是属于对象的

#### 动态链接库的使用方法？

静态调用：将.dll, .lib, .h文件拷贝到工程目录，VS设置-链接器-附加依赖项中输入.lib，工程加入.h文件。

动态调用：调WIN32 API函数LoadLibrary、GetProcAddress。

编译：.h；链接：.lib；运行：.dll。当我们在自己的程序中引用了一个H文件里的函数,编链器怎么知道该调用哪个DLL文件呢?这就是LIB文件的作用: 告诉链接器调用的函数在哪个DLL中，函数执行代码在DLL中的什么位置，这也就是为什么需要附加依赖项.LIB文件，它起到桥梁的作用。如果生成静态库文件，则没有DLL，只有lib，这时函数可执行代码部分也在lib文件中

#### 判断一个点是否在三角形内？

内角和法、点边同侧法、面积法、向量法（同侧法改进）。

#### 对智能指针的理解。

智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。

#### 智能指针有哪几种？shared_ptr和unique_ptr的区别？在编译期还是运行期做校验？

shared_ptr（引用计数）、unique_ptr（唯一）、weak_ptr（避免循环引用）、auto_ptr（已弃用）。编译期。

循环引用：A中有指向B的智能指针，B中有指向A的智能指针，引用计数都为2，跳出时减1，都为1，没有被析构。把其中一个改为weak_ptr，计数仍为1，可以正常析构。

#### 智能指针之间的赋值方式有哪些？浅拷贝和深拷贝区别？

浅拷贝就是拷贝对象内部的各成员的值。深拷贝就是不光拷贝成员的值（一般是非指针类型的成员），还额外的拷贝指针成员指向的内容（所以说这些内容不是对象的组成部分而只是被对象所管理）。默认拷贝构造都是浅拷贝，深拷贝要靠自己写来实现。智能指针用=或()赋值是浅拷贝。

#### shared_ptr和uniqe_ptr底层原理？

shared_ptr：维护一个指向引用数量的成员指针，拷贝构造和拷贝赋值浅拷贝并自增指针指向值。

uniqe_ptr：删除拷贝构造和拷贝赋值

#### 智能指针怎么指向数组？删除器是什么？

shared_ptr用new[]构造，需要指定自定义删除器。

unique_ptr直接支持new[]构造。

删除器就是自定义的删除方法，在构造智能指针时传入函数名。

#### 智能指针怎么转换？

static_pointer_cast、dynamic_pointer_cast、const_pointer_cast。weak_ptr的lock方法可以返回shared_ptr，若expired为false即引用计数不为0，返回后由shared_ptr接管，否则返回空的shared_ptr。

#### shared_ptr是线程安全的吗？引用计数怎么确保线程安全的？

读、引用计数线程安全，写不安全。atomic原子操作。

#### 构造函数能抛出异常吗？ 

语法上可以，但尽量不要，避免内存泄漏。使用智能指针做管理可防止内存泄漏。

#### 递归过多会出现什么问题？

堆栈溢出。32位机上栈空间2M，堆空间4G。

#### C++11有哪些新特性？对泛型的理解？ 

范围for循环、auto、lambda、后置返回类型、override和final、nullptr、long long int、模板的别名、tuple、右值引用。泛型：template。

#### 对右值引用的理解？移动构造为什么开销小？push_back何时使用右值引用？怎么实现完美转发？

左值是可以取地址的变量，右值不可。右值引用通过移动语义来避免无谓拷贝的问题，通过move语义来将临时生成的左值中的资源无代价的转移到另外一个对象中去。移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。push_back当对象有移动构造且可用时，会优先调移动构造。

完美转发：A中调用B，当A的参数是右值的时候，B的参数也是右值；当A的参数是左值的时候，B的参数也是左值。实现：std::forward<T>处理参数t，因为T&&有可能是通用引用（函数模板、auto会发生）。

#### 强类型和弱类型？

强类型：类型安全；弱类型：类型不安全（隐式类型转换）。

#### dynamic_cast是做什么的？

转换类指针、类引用或void*，主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。

#### 基类中的private虚函数作用？怎么被子类访问？

建议子类override，但不要调用。通过基类的非虚public函数，或者用指针取出类的首地址。

#### 虚函数与模板机制的不同？

模板是静多态，模板是在编译时确定的，而虚函数是动多态，是在运行时确定。

#### extern C的作用？

extern：引用一个全局变量。为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。如果不加，链接器会找不到这个符号链接。原因：C无重载函数，编译后的函数名与C++不一样。

#### static的应用场景？如何访问static成员？

1、在模块内定的静态全局变量或函数可以被该模块的所有函数调用，不能被模块外的使用，起到了隐藏的功能。

2、函数体内的静态变量在该模块初次运行时进行初始化，且仅初始化一次。保存上次调用的值，直到下次调用，其作用域为该函数。

3、类中的静态成员函数只能访问静态成员变量。它不接收this指针。

4、类中的静态变量属于整个类，不属于任何类的对象。但是可以由类，类的对象，类的指针或引用调用。

访问：类名+::、成员函数。

#### 函数的默认参数在声明还是定义时给出？同一个函数的同一个默认参数可以有多种吗？

都可以，但通常放在声明中，若在定义中则必须在同一个文件使用默认参数。不能。

#### 类的默认生成函数有哪些？

构造、析构、赋值、拷贝构造。

#### 从cpp文件到可执行文件的过程？

.cpp——预处理——.i——编译——.s——汇编——.obj——链接——.exe

<img src="/Users/wtb/Library/Application Support/typora-user-images/image-20230705142602286.png" alt="image-20230705142602286" style="zoom:50%;" /> 

#### C语言为什么没有重载？

比如一个函数的声明如下：

void  function(int x,int y)；

在c语言中，编译器在编译后在库中的名字为_function

在c++中，编译器在编译后在库中的名字为_function_int_int

在链接时，都是找名字进行链接的,就比如以上两个函数，

在C语言中两个的名字一样，就会在链接中报错。

C++中它们的名字不一样，所以就不会报错。

#### 空类能编译通过吗？大小是多少？

能，1

#### STL容器分别是不是线程安全的？

STL允许在一个容器上的多线程读取和不同容器上的多线程写入，除此之外不能依赖任何库自带的线程安全性。线程不安全示例：别的线程修改容器后iterator会失效。

#### 数组和指针的区别？

数组作为左值时相当于一片连续内存区的管理者，有自己的操作符行为；作为右值时相当于一个指针，对应的是数组首元素的地址。

#### 迭代器失效的几种情况？

连续内存：插入点和删除点之后的迭代器全部失效。

链表、树：删除点失效。

#### map和unordered_map的区别？

1、 map红黑树，有序，查找O(logn)；unordered_map哈希表，无序，查找O(1)。

2、map的key需要比较函数，unordered_map的key需要哈希函数，默认只能用基本类型和指针，map可以直接用vector、pair等复杂数据结构做key。

3、对内存要求严格，时间要求不严格时，因哈希表内存开销略多，用map较好。

#### 除了rehash，怎么优化哈希冲突？

二次哈希，红黑树。

#### stack为什么用deque不用vector实现？

stack频繁的push元素，若用vector会屡次触发扩容机制，开销大，deque则小得多。

#### deque默认每段连续内存有多少空间？和vector相比的优势和缺陷？

512字节。deque可以很方便的在双端插入删除，且不会像vector的自动扩容一样复制整个容器的元素，但占用内存多，不是完全的连续内存，不能高效的随机存取。

#### vector的自动扩容为什么不用realloc实现，而要重新开辟内存？

realloc 在不可原地扩展时会申请新空间加上内存拷贝，对于非平凡结构（不能按字节拷贝的类），元素如果引用或间接引用了vector内存范围内地址，搬运就是非法的。

#### vector怎么释放内存？

C++11以前：vec.swap(vector<int>())；C++11以后：vec.shrink_to_fit()。

#### string的实现原理？怎么处理内存碎片的？

C字符串+迭代器和函数做管理。用内存池接管内存碎片。

#### STL中sort的实现原理？

<img src="/Users/wtb/Library/Application Support/typora-user-images/image-20230705143434016.png" alt="image-20230705143434016" style="zoom: 50%;" /> 

#### 异常安全是什么？怎么实现异常安全？

三个等级。1、基本保证：抛出异常后，对象仍然处于合法（valid）的状态，但不确定处于哪个状态。2、强烈保证：如果抛出了异常，程序的状态没有发生任何改变，就像没调用这个函数一样。3、不抛异常保证：这是最强的保证，函数总是能完成它所承诺的事情。可以用"copy and swap"设计策略来实现强烈的保证。

#### C++11以后版本的特性？

C++14：泛型lambda。

C++17：非类型模板参数的auto。

#### 单参数的构造函数为什么不被推荐？

影响代码可读性，隐式转换可能带来危害。

<img src="/Users/wtb/Library/Application Support/typora-user-images/image-20230705145350647.png" alt="image-20230705145350647" style="zoom: 67%;" /> 

#### C++11线程方面的特性？

std::thread可以和普通函数和lambda表达式搭配使用。它还允许向线程执行函数传递任意多参数。

#### 什么是字节对齐？为什么要对齐？

计算机中内存空间按照字节划分，为了提高效率，计算机从内存中取数据是按照一个固定长度的。以32位机为例，它每次取32个位，也就是4个字节，如果变量在内存中存放的位置按4字节对齐，那么只需要取一次就可以了。

#### ABC三个线程循环打印abc，每个线程有哪些步骤？

主线程定义一个cnt变量，一个bool变量，一把锁，3个条件变量，每个线程先获取锁，然后用条件变量wait，通过cnt的对应值唤醒，唤醒后打印，修改cnt，并用下一个条件变量notify。其中A线程的条件当bool变量为false也可唤醒，并置其为true，确保A线程是第一个打印的。

#### 怎么判断大端小端？

void IsBigEndian()

{

​	short int a = 0x1122; //十六进制，一个数值占4位

​	char b = *(char*)&a;  //通过将short(2字节)强制类型转换成char单字节，b指向a的起始字节（低字节）

​	if (b == 0x11) //低字节存的是数据的高字节数据

​		//是大端模式

​	else

​		//是小端模式

}

#### strcpy和memcpy的区别？

strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符。memcpy提供了一般内存的复制，对于需要复制的内容没有限制，根据其第3个参数决定复制的长度。

#### 程序运行的内存模型

- 程序代码区
- 常量区存放常量。程序结束时由OS回收。
- 全局区（静态区）存放全局变量和静态变量。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 程序结束时由OS回收。
- 堆区存放的变量（用new，malloc，calloc，realloc等分配内存函数得到的变量）由程序员分配释放。
- 栈区存放的变量（局部变量、函数参数等）由编译器自动分配释放。

栈区和堆区的关系：
1.当一个函数调用完返回后它会释放该函数中所有的栈空间。栈是由编译器自动管理的，不用你操心。堆是动态分配内存的，并且你可以分配使用很大的内存，但是用不好会产生内存泄漏（比如在for循环中忘记释放申请的内存）。
2.栈是机器系统提供的数据结构，特点是快速高效，不会产生内存碎片，缺点是有限制，数据不灵活。
3.堆是C/C++函数库提供的，特点是灵活方便，数据适应面广泛，但是效率有一定降低，频繁申请和释放内存会产生内存碎片。

#### 如何定位内存泄漏？内存泄漏有哪些情况？

_CRTDBG_MAP_ALLOC。new/malloc和delete/free未成对出现；new[]未用delete[]释放；delet void*的指针，导致没有调用到对象的析构函数；没有将基类的析构函数定义为虚函数；抛出异常时未释放堆上变量。

#### 野指针是什么？哪些情况会产生？

野指针是指向不可用内存区域的指针。产生：1、指针变量没有被初始化。2、指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。3、指针操作超越了变量的作用范围。



# Python

#### 数据结构及底层

列表：长度可变的数组（类似C++ vector）

元祖：大小固定的数组

字典、集合：哈希表

collections.deque：双向链表

#### 元祖的不可变？

不能对元祖的某个元素直接赋值，当元组中含有可变的变量类型时，元组内容是可变的，不变的是指向该内容的地址                                                                    

#### 生成器和迭代器？

迭代器：用于迭代操作（for 循环）的对象，它像列表一样可以迭代获取其中的每一个元素，任何实现了\_\_iter\_\_和\__next__方法的对象都可以称为迭代器。

生成器：迭代器的一种，使用yield返回值函数，每次调用yield会暂停并保存当前所有的运行信息，返回yield的值，需要调用next方法或者for循环来持续输出结果，可以节省内存。python2的xrange和python3的range就是用生成器实现。

#### 什么是闭包？装饰器又是什么？装饰器有什么作用？使用举例？

在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用，这样就构成了一个闭包。装饰器本质上是一个python函数，让其他函数在不需要做任何代码变动的前提下增加额外的功能，通过闭包实现，返回值也是一个函数对象。装饰器是导入时运行的，而被装饰的函数是明确调用时运行的。Flask框架就大量使用装饰器实现url映射和允许的http请求方法等，classmethod装饰器不用实例化类对象就可调用方法。

#### classmethod vs staticmethod

同：都可以不用实例化的调用类方法。

异：classmethod可以通过cls调用类内方法和变量， 可以用来为一个类创建一些预处理的实例（工厂模式）；staticmethod只能直接类名.属性名或类名.方法名调用，就像非类成员函数一样，常用于代码块维护。

#### python程序运行原理

python解释器(Cpython)会将test.py编译成一个字节码对象PyCodeObject， .pyc文件其实就是PyChodeObject这个字节对象在硬盘上的表现形式 ， 包含了Python代码汇总所有的字符串、常量值、以及通过语法解析后编译生成的字节码指令 。 Python虚拟机会从编译得到的PyCodeObject对象中依次读入每一条字节码指令，在当前的上下文环境中执行这条字节码，Python程序就这样跑起来了。 

#### GIL锁？多线程程序还有没有必要手动加锁？

 GIL(全局解释器锁)是CPython的特性，通过线程间的全局互斥锁(mutex)防止多线程并发执行机器码。在抢占式多任务处理中（如对全局变量+1-1），由于多个线程同时竞争GIL，不确定谁会竞争成功，仍然存在线程不安全问题。CPU密集型且计算操作不是原子操作时需要考虑线程安全，此外不需要。

####          copy和deepcopy区别？  

copy是浅拷贝，只对原始对象的第一层做拷贝，如果有嵌套类型则只拷贝了引用，仍随着内层对象改变而改变。deepcopy是深拷贝，会递归地拷贝嵌套类型的最后一层，无论原始变量的哪一层改变都不影响拷贝对象。

#### 垃圾回收

主要通过引用计数进行垃圾回收；通过 “标记-清除” 解决容器对象可能产生的循环引用问题；通过 “分代回收” 以空间换时间的方法提高垃圾回收效率。 

引用计数：每个对象维护一个字段记录被引用次数，归零后回收内存空间。缺点：循环引用导致内存泄露。

标记清除： 对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。  从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 标记清除主要用来回收容器对象， 比如 list、dict、tuple，instance 等 。

分代回收： 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python 将内存分为了 3“代”，分别为年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代），他们对应的是 3 个链表，它们的垃圾收集频率随对象的存活时间的增大而减小 。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。

有三种情况会触发垃圾回收：

1. 调用`gc.collect()`,需要先导入`gc`模块。
2. 当`gc`模块的计数器达到阀值的时候。
3. 程序退出的时候。

#### Django处理请求的过程？

![Django 处理请求流程](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/27/1688d00d3d8f4c20~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image) 

1. 请求发送到了wsgi，wsgi 封装请求的相关数据（request）
2. 请求到达Request Middlewares，中间件对request做一些预处理或者直接response请求 
3. URLConf通过urls.py文件和请求的URL找到相应的View
4. *View Middlewares被访问，它同样可以对request做一些处理或者直接返回response 
5. 调用View中的函数，处理具体的业务逻辑，可以选择性的通过Models访问底层的数据
6. 函数返回响应，django按照 HTTP 协议的响应的格式进行返回



# Go

#### 指针的作用

获取变量的值；改变变量的值；用指针替代值传入函数，比如类的接收器

#### 异常类型

用error类型代替try...catch语句，这样可以节省资源，同时增加代码可读性。也可以用errors.New()来定义自己的异常

#### 协程（Goroutine）

协程是**用户态轻量级线程**，它是**线程调度的基本单位**。通常在函数前加上go关键字就能实现并发。一个Goroutine会以一个很小的栈启动2KB或4KB，当遇到栈空间不足时，栈会**自动伸缩**， 因此可以轻易实现成千上万个goroutine同时启动。 

#### 如何高效地拼接字符串

strings.Join ≈ strings.Builder > bytes.Buffer > "+" > fmt.Sprintf 

"+"和fmt.Sprintf每次都开辟新的空间遍历字符串，且后者用反射获取值，损耗更大

strings.Builder和bytes.Buffer类似C++ vector，每次内存不够时成倍扩容，其中bytes.Buffer有[]byte和string转换的损耗，strings.Join可以自定义分隔符，并且调用了strings.Builder中的Grow方法预分配内存，性能最佳

#### 什么是 rune 类型

 Unicode CodePoint ， 在 Go 语言中称之为 rune，是 int32 类型的别名 （ 字符串的底层表示是 byte (8 bit) 序列，而非 rune (32 bit) 序列 ）

#### Go 支持默认参数或可选参数吗？

 不支持。但是可以利用结构体参数，或者...传入参数切片数组。 

#### defer 

 defer执行顺序和调用顺序相反，类似于栈 ， 在return之后执行， 对于defer有名返回值的函数（ func test() (i int) ）可在外函数退出前修改变量，否则defer内的改动不生效

#### channel线程安全吗？

安全。当一个 Goroutine 向 Channel 发送数据时，直到另一个 Goroutine 接收到这个数据之前，该 Goroutine 将会被阻塞。这种机制保证了 Channel 的数据在 Goroutine 之间传递时的安全性。

#### new和make区别

new只分配内存，可分配任意类型，返回指针。

make用于slice，map，和channel的初始化，同时会初始化零值，返回引用类型。

#### GC机制

三色标记 + 混合写屏障：https://learnku.com/articles/59021

- 初始状态下所有对象都是白色的
- 从根节点开始遍历所有对象，把遍历到的对象变成灰色对象
- 遍历灰色对象，将灰色对象引用的对象也变成灰色对象，然后将遍历过的灰色对象变成黑色对象。
- 循环步骤3，直到灰色对象全部变黑色
- 通过写屏障(write-barrier)检测对象有变化，重复以上操作
- 回收所有白色对象（垃圾）

混合写屏障分下面四步：

- GC 开始时将栈上可达对象全部标记为黑色（不需要二次扫描，无需 STW）
- GC 期间，任何栈上创建的新对象均为黑色
- 被删除引用的对象标记为灰色
- 被添加引用的对象标记为灰色

触发条件：触发 GC 有俩个条件，一是堆内存的分配达到控制器计算的触发堆大小，初始大小环境变量 GOGC，之后堆内存达到上一次垃圾收集的 2 倍时才会触发 GC。二是如果一定时间内没有触发，就会触发新的循环，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟



# 云原生

####          operator informer机制 ？list & watch实现？

https://blog.csdn.net/qq_24433609/article/details/126020290

https://zhuanlan.zhihu.com/p/59660536

list & watch：list api基于http短连接获取实时全量数据，watch api基于http长连接获取异步增量数据（此处的长连接用了http/1.1的分块传输编码，通过在response的HTTP Header中设置Transfer-Encoding的值为chunked， 不需要预先知道发送内容的总大小 ）。 当watch API丢失消息，周期的list api仍能获取最新数据，纠正状态不一致的资源，且比单纯轮询list api开销小很多。

informer：初始化时，reflector调用list api获取resource的全部object，缓存在内存中，之后完全依赖watch维护缓存。informer支持自定义创建、更新和删除的回调函数。

####          etcd会直接和哪些组件交互？  

只有apiserver

#### api版本控制

v1表示正式版，v1alpha表示实验室版，，v1beta表示预发布版，通过url中追加版本号实现多版本控制，如/apis/batch/v1beta1/namespaces/{namespace}/cronjobs

#### 创建pod过程？sheduler调度流程？

创建pod：

- 用户通过kubectl命令发起请求。
- apiserver通过对应的kubeconfig进行认证，认证通过后将yaml中的po信息存到etcd。
- Controller-Manager通过apiserver的watch接口发现了pod信息的更新，执行该资源所依赖的拓扑结构整合，整合后将对应的信息交给apiserver，apiserver写到etcd。
- Scheduler同样通过apiserver的watch接口更新到pod可以被调度，通过算法给pod分配节点，并将pod和对应节点绑定的信息交给apiserver，apiserver写到etcd。
- kubelet从apiserver获取需要创建的pod信息，调用CNI接口给pod创建pod网络，调用CRI接口去启动容器，调用CSI进行存储卷的挂载。
- 网络，容器，存储创建完成后pod创建完成，等业务进程启动后，pod运行成功

scheduler调度：

- schedule()：执行predicate调度算法和priority调度算法，对选出的node按得分大小排序，返回得分最高的nodeName。
- ssume()：如果调度成功则将pod写入本地缓存schedulerCache，同时对本地缓冲中node资源占用进行更新，以便下次调度时以此最新的缓存作为参考。
- bind()：异步将pod的Binding信息写入到kube-apiserver中。一次调度完成。

#### delete pod过程？如果是多副本？

- 用户发出删除pod请求，apiserver收到该请求之后判断出pod支持优雅删除，将更新etcd中该pod的DeletionTimestamp、DeletionGracePeriodSeconds字段，etcd中该pod的rv变化，此时controller  reflector收到一个Modify event
- kubelet reflector watch到上述update事件，开始kill pod中的容器，完成后请求apiserver更新pod的status信息，api将更新etcd中该pod 的condition和containerStatuses等字段，etcd中该pod的rv变化，此时controller reflector收到一个Modify event
- pod对象在优雅推出时间内完成prestop指令后，容器进程收到 TERM 信号结束
- kubelet完成上述过程之后，会向apiserver再次发送一个delete pod请求，希望api直接删除该pod，api将更新etcd中该pod的DeletionGracePeriodSeconds字段为0， etcd中该pod的rv变化，此时controller收到一个Modify event
- apiserver把etcd中的pod的记录删除，但etcd中仍然会记录该pod并更新其rv，此时无法通过api获取到该pod的信息，controller此时可以收到一个Delete event
- 如果是多副本，删除pod后controller发现副本数比预期少了，向apiserver发送创建pod的请求，apiserver通过scheduler获取调度节点信息，写入etcd，并调用kubelet创建

#### controller manager, scheduler

Controller Manager 集群内部的管理控制中心，其主要目的是实现Kubernetes集群的故障检测和恢复的自动化工作，其他诸如Node的发现、管理和状态监控、死亡容器所占磁盘空间及本地缓存的镜像文件的清理等工作也是由Controller Manager完成的。

kubernetes scheduler是集群中的调度器，负责Pod在集群节点中的调度分配。

#### CNI

K8s 中标准的一个调用网络实现的接口。Kubelet 通过这个标准的 API 来调用不同的网络插件以实现不同的网络配置方式。腾讯使用的是 flannel 。

CNI的三种实现模式：Overlay、路由、Underlay。

Overlay 模式的典型特征是容器独立于主机的 IP 段，这个 IP 段进行跨主机网络通信时是通过在主机之间创建隧道的方式，将整个容器网段的包全都封装成底层的物理网络中主机之间的包。该方式的好处在于它不依赖于底层网络

路由模式中主机和容器也分属不同的网段，它与 Overlay 模式的主要区别在于它的跨主机通信是通过路由打通，无需在不同主机之间做一个隧道封包。但路由打通就需要部分依赖于底层网络，比如说要求底层网络有二层可达的一个能力

Underlay 模式中容器和宿主机位于同一层网络，两者拥有相同的地位。容器之间网络的打通主要依靠于底层网络。因此该模式是强依赖于底层能力的

#### openkruise

cloneset用于业务pod原地升级，sidecarset用于debugger sidecar原地升级

原地升级原理：

1. 先将 pod.status.conditions 中的 InPlaceUpdateReady condition 设为 "False"，这样就会触发 kubelet 将 Pod 上报为 NotReady，从而使得Controller将这个 Pod 从服务端点摘除；
2. 更新 pod 的 spec.containers[x] 中的 image 触发原地升级，kubelet 会感知到这个 container 的 hash 发生了变化，随即就会停掉对应的旧容器，并用新的 container 来拉镜像、创建和启动新容器。（这里也可以使用 `gracePeriodSeconds` 来设置修改NotReady状态和真正更新image两个步骤之间的等待时间。来保证服务有足够时间关闭。）
3. 原地升级结束后，再将 InPlaceUpdateReady condition 设为 "True"，使 Pod 重新回到 Ready 状态。

#### ETCD，Raft算法

no sql的存储，存的是key-value的node，每个node又可以像树形结构一样产生子node。它是集群化的运行状态来保证高可用，并且对外提供了一套简单友好的交互接口

leader：对客户端通信的入口，对内数据同步的发起者，一个集群通常只有一个leader节点

follower：非leader的节点，被动的接受来自leader的数据请求

candidate： 一种临时的角色，只存在于leader的选举阶段，某个节点想要变成leader，那么就发起投票请求，同时自己变成candidate。如果选举成功，则变为leader，否则退回为follower 

数据提交过程：leader收到数据操作的请求，先不着急更新本地数据，生成log并广播给所有follower，每个follower自主选择是否接受，若接受则写入log并返回success，否则返回false。当超过半数的follower写了log，leader开始第二阶段的提交，正式写入数据，然后同样广播给follower，follower也根据自身情况选择写入或者不写入并返回结果给leader。两阶段任意一个若超过半数follower返回false或无返回，分布式事务不会成功，没有回滚，但会被后续事务覆盖。

选举过程：每个follower内部都维护了一个随机的timer，在timer时间到了的时候还没有人主动联系它的话，那它就要变成candidate，同时发出投票请求（RequestVote）给其他follower。每个follower一轮只能投一次票给一个candidate，对于相同条件的candidate，follower们采取先来先投票的策略。如果超过半数的follower都投给了某个candidate，则新的leader产生。之后leader和follower之间通过心跳检测互相感知存活。

问题：某个candidate选举时数据丢失，其他follower不会投票，通过在 vote请求中带上包含log索引index和任期号term的描述信息实现。

#### cgroups

cgroups 是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，可以对 cpu，内存等资源实现精细化的控制，目前越来越火的轻量级容器 Docker 就使用了 cgroups 提供的资源限制能力来完成cpu，内存等部分的资源控制 

#### scheduler的3个queue

activeQ：即ready队列，里面都是准备调度的Pod，新添加的Pod都会被放到该队列，从调度队列中弹出需要调度的Pod也是从该队列获取
unschedulableQ：不可调度队列，里面有各种原因造成无法被调度Pod
backoffQ：退避队列，里面都是需要可以调度但是需要退避一段时间后才能调度的Pod

#### RDMA

它的原理是将待传输的数据从一台计算机的内存，直接传输到另一台计算机的内存，整个传输过程无需操作系统和协议栈的介入。由于旁路了操作系统协议栈，通讯过程极大的降低了CPU的使用率，减少了内核的内存复制，以及用户态与内核态的上下文切换。



# 数据结构与算法

#### 各排序算法的时空复杂度

<img src="/Users/wtb/Library/Application Support/typora-user-images/image-20230706114847875.png" alt="image-20230706114847875" style="zoom:67%;" /> 

#### 找出数组中第k小的数

快速选择算法，时间复杂度O(n)

```python
def partition(nums, lo, hi):
    x = nums[hi]
    i = lo
    for j in range(nums):
        if nums[j] < x:
            nums[i], nums[j] = nums[j], nums[i]
            i += 1
    nums[hi] = nums[i]
    nums[i] = x
    return i

def find_k_th_smallest(nums, k):
    lo, hi = 0, len(nums) - 1
    while lo < hi:
        i = partition(nums, lo, hi)
        if i == k:
            break
        if i > k:
            hi = i - 1
        else:
            lo = i + 1
    return nums[k - 1]
```

#### 堆

插入：插入到队尾，然后从最后一个非叶子结点一直到根结点进行堆化的调整，如果当前结点小于自己的某个孩子结点（大根堆中），则交换。

删除：只能删除堆顶。将堆的最后一个结点赋给堆顶，删除最后一个结点，并将堆自顶向下调整。

#### BST树

删除：node没有左子树或右子树，直接删除并返回孩子；都有，则找到其左子树中的最大值结点max，将其赋值给node，并删除max。

#### 红黑树

性质1：每个节点要么是黑色，要么是红色。

性质2：根节点是黑色。

性质3：每个叶子节点（NIL）是黑色。

性质4：每个红色结点的两个子结点一定都是黑色。

性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。

从性质5又可以推出：

性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。

对P左旋相当于AVL树中对P->right右右旋，对P右旋相当于AVL数中对P->left左左旋。

#### AVL树

对P左旋相当于AVL树中对P.right右右旋，对P右旋相当于AVL树中对P.left左左旋。

#### 并查集

一种树形结构，处理一些不相交集合的合并及查询问题

查找：确定元素属于哪一个子集，即返回根结点。

合并：将两个子集合并成一个集合（将两个结点的根结点连在一起）。

#### 哈希表的实现细节？rehash步骤？

用数组作为桶，链表解决哈希冲突。当达到负载因子后，重新开辟更大的数组空间，将原哈希表元素一一映射到新表，然后释放内存。redis采用渐进式rehash，每次对字典执行添加、删除、查找或更新操作时，都会执行一次渐进式rehash。以下是哈希表渐进式 rehash 的详细步骤：

1. 为 `ht[1]` 分配空间， 让字典同时持有 `ht[0]` 和 `ht[1]` 两个哈希表。
2. 在字典中维持一个索引计数器变量 `rehashidx` ， 并将它的值设置为 `0` ， 表示 rehash 工作正式开始。
3. 在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 `ht[0]` 哈希表在 `rehashidx` 索引上的所有键值对 rehash 到 `ht[1]` ， 当 rehash 工作完成之后， 程序将 `rehashidx` 属性的值增一。
4. 随着字典操作的不断执行， 最终在某个时间点上， `ht[0]` 的所有键值对都会被 rehash 至 `ht[1]` ， 这时程序将 `rehashidx` 属性的值设为 `-1` ， 表示 rehash 操作已完成。

#### 无锁队列

基于CAS (Compare & Swap) 实现原子操作。https://zhuanlan.zhihu.com/p/365423058

```c
// CAS
bool compare_and_swap(int *addr, int oldval, int newval)
{
  if ( *addr != oldval ) {  // 其他线程已经变更了该值，返回失败
      return false;
  }
  *addr = newval;  // 未被其他线程变更，进行变更
  return true;
}

// 初始化队列
InitQueue(Q)
{
    node = new node()
    node->next = NULL;
    Q->head = Q->tail = node;
}

// 入队列
EnQueue(Q, data)
{
    // 准备新加入的结点数据
    n = new node();
    n->value = data;
    n->next = NULL;
    do {
        p = Q->tail;  // 取链表尾指针的快照
    } while (compare_and_swap(p->next, NULL, n) != true);  // 如果尾结点tail.next不为null，CAS失败，重试入队列，直到成功并加入n
    compare_and_swap(Q->tail, p, n);  // 置尾结点tail = n;
}

EnQueue(Q, data) //进队列改良版 v2 
{
    n = new node();
    n->value = data;
    n->next = NULL;
    while(TRUE) {
        //先取一下尾指针和尾指针的next
        tail = Q->tail;
        next = tail->next;
        //如果尾指针已经被移动了，则重新开始
        if ( tail != Q->tail ) continue;
        //如果尾指针的 next 不为NULL，则 fetch 全局尾指针到next
        if ( next != NULL ) {
            CAS(Q->tail, tail, next);
            continue;
        }
        //如果加入结点成功，则退出
        if ( CAS(tail->next, next, n) == TRUE ) break;
    }
    CAS(Q->tail, tail, n); //置尾结点
}

// 出队列
DeQueue(Q)
{
    do {
        p = Q->head;
        if (p->next == NULL) {
            return ERR_EMPTY_QUEUE;
        }
    }
    while( CAS(Q->head, p, p->next) != TRUE );
    return p->next->value;
}
  
DeQueue(Q) //出队列，改进版
{
    while(TRUE) {
        //取出头指针，尾指针，和第一个元素的指针
        head = Q->head;
        tail = Q->tail;
        next = head->next;
        // Q->head 指针已移动，重新取 head指针
        if ( head != Q->head ) continue;
        
        // 如果是空队列
        if ( head == tail && next == NULL ) {
            return ERR_EMPTY_QUEUE;
        }
        
        //如果 tail 指针落后了
        if ( head == tail && next == NULL ) {
            CAS(Q->tail, tail, next);
            continue;
        }
        //移动 head 指针成功后，取出数据
        if ( CAS( Q->head, head, next) == TRUE){
            value = next->value;
            break;
        }
    }
    free(head); //释放老的dummy结点
    return value;
}
```

CAS的ABA问题：

- 进程P1在共享变量中读到值为A
- P1被抢占了，进程P2执行
- P2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。
- P1回来看到共享变量里的值没有被改变，于是继续执行。

解决：使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容

- 一次用CAS检查双倍长度的值，前半部是值，后半部分是一个计数器。
- 只有这两个都一样，才算通过检查，赋新的值，并把计数器累加1。

#### 洗牌算法

- 每次从剩下的牌组随机抽一张放到新数组，时间O(n²)，空间O(n)。
- 每次随机取下标后，和尾元素交换，然后随机范围-1，时间O(n)，空间O(1)。必须知道数组长度。
- 从前往后扫描，将每个元素随机插入到之前的任意位置，时间O(n)，空间O(n)。无需知道数组长度。

#### LRU

<img src="/Users/wtb/Library/Application Support/typora-user-images/image-20230706145928050.png" alt="image-20230706145928050" style="zoom:50%;" /> 

时间复杂度O(1)

#### *在10亿数据中找出频数最高的10个？内存受限

1. 以内存1M为例，对每个数x，取hash(x) % 2000，然后按该值存到2000个小文件，每个文件大约500k
2. 对每个文件，用字典存{数据: 频数}，然后用最小堆遍历字典，O(N) + O(Nlogk)，并把10个数及相应的频数存入新的2000个文件
3. 对这2000个新文件归并排序

#### 抢红包算法

二倍均值法：剩余红包金额为M，剩余人数为N，每次抢到的金额 = 随机区间 (0,  M / N * 2)，保证了每次随机金额的平均值是相等的，不会因为抢红包的先后顺序而造成不公平。

线段切割法：将一个红包看作是一个线段，线段的长就是红包总金额，然后在这个线段上随机切 n-1 刀，分成 n 份，然后抢红包的人依次来取即可。

#### 两个大文件查找公共url？

遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件，对文件b做同样的操作。现在问题转换成了：找出1000对小文件中每一对相同的url，可以用hash_set来做。也可将1000对小文件进一步划分，做多级哈希。

#### 100亿个数中找出中位数？

（1） 内存足够：见剑指offer，一个大顶堆一个小顶堆遍历数组；或用快速选择找第50亿的数。

（2） 内存不足：把所有数划分到各个小区间，把每个数映射到对应的区间里，对每个区间中数的个数进行计数，数一遍各个区间，看看中位数落在哪个区间，若够小，使用基于内存的算法，否则继续划分。

#### 在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内，有一个数字重复了，怎么找出？

将值为 i 的元素调整到第 i 个位置上，若第i个位置已经有该值了，则找到。

#### 树的前中后序和层序的适用场景？

前中后序为DFS，用递归和栈实现。前序遍历可以用来实现目录结构的显示，中序遍历可以用来做表达式树，在编译器底层实现的时候用户可以实现基本的加减乘除，比如 a*b+c，后序遍历可以用来实现计算目录内的文件占用的数据大小。

层序遍历为BFS，用队列实现，可以求最短路径等。

#### 常见哈希算法

MD4, MD5, SHA-1等。解决哈希冲突：线性探查、Rehash、链地址法（java用红黑树优化）。

#### 延时队列

https://zhuanlan.zhihu.com/p/480105174



# 数据库

#### 为什么要有事务？四大特性？

保证数据最终的一致性。事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。原子性、一致性、隔离性、持久性。

- 原子性：事务最为不可分割的最小单元，所有操作要么全部成功要么全部回滚。**实现：undo log**
- 一致性：数据库在事务执行前后都保持一致性状态，所有事务对一个数据的读取结果都是相同的。
- 隔离性：一个事务所做的修改在提交前，对其它事务不可见。**实现：锁、MVCC**
- 持久性：一旦事务提交，将永久保存，即使系统崩溃也不丢失。**实现：redo log**

#### 数据库存储文本有几种格式选择？char和varchar的区别？

| **类型**   | **大小**            | **用途**                        |
| ---------- | ------------------- | ------------------------------- |
| CHAR       | 0-255字节           | 定长字符串                      |
| VARCHAR    | 0-65535 字节        | 变长字符串                      |
| TINYBLOB   | 0-255字节           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255字节           | 短文本字符串                    |
| BLOB       | 0-65 535字节        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535字节        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215字节    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295字节 | 极大文本数据                    |

char定长，文本后有空格，varchar变长，文本后无空格，但比char多1~2个字符存储长度。char检索速度更快，但费空间。

#### 并发一致性问题及对应的最高隔离级别？事务的隔离级别及其实现？

丢失修改（未提交读）、脏读（未提交读）、不可重复读（提交读）、幻读（可重复读）。

- 未提交读：事务中的修改在提交前对其它事务也可见。**实现：写时加行级共享锁，事务结束释放**

- 提交读：事务中的修改在提交前对其它事务不可见。**实现：读时加行级共享锁，读完释放；写时加行级排它锁，事务结束释放**

- 可重复读：同一个事务多次读结果一致。**实现：读时加行级共享锁，事务结束释放；写时加行级排它锁，事务结束释放。innodb下使用MVCC+临键锁实现并解决幻读**

- 可串行化：强制事务串行执行。**实现：读时加表级共享锁，事务结束释放；写时加表级排它锁，事务结束释放。**

#### 索引的实现原理

B+树：

- 非叶子结点存索引，实际数据或指针存在叶子结点，并且用链表相连，方便扫库

- B+树比B树的磁盘IO代价更低（内部结点并没有指向关键字具体信息的指针，相对B树更小）
- 查询效率比B树稳定（所有关键字查询路径长度相同）
- 比B树更适合区间查询（叶子结点用链表相连，方便扫库）

myisam的索引文件和数据文件分离，索引文件仅保存数据记录的地址。innodb中，表数据文件本身就是按B+树组织的一个索引结构，其叶子结点的data域保存了完整的数据记录，索引的key是主键，因此innodb表数据文件本身就是主索引。

innodb分主索引和辅助索引，主索引的叶子节点data域记录完整数据记录，称为聚簇索引，无法把数据行存放在两个不同的地方，一个表只能有一个聚簇索引。辅助索引的叶子结点data域记录主键的值，因此在使用辅助索引查询时，需要先找到主键值，再到主索引中查询。

还有其它索引类型：B-tree、哈希索引、空间数据索引（R-tree）、全文索引等。

#### mysql哪些情况下索引会失效？

- 组合索引不满足最左前缀（第一列必用，中间不能断）
- 组合索引的非最左列适用范围条件（between, <>, in等）
- 对索引列做计算或函数等操作（如key-1=5, key=5+1, left(key, 3)）
- 查询条件包含or
- like模糊查询时%在前缀
- 数据量小时，全局扫描比查索引更快，不会走索引

#### 索引下推，覆盖索引

索引下推：将部分上层（服务层）负责的事情，交给了下层（引擎层）去处理，减少回表次数，通过where后的字段命中联合索引的最左前缀实现，在Innodb引擎中适用于辅助索引

覆盖索引：从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，通过建立联合索引，select的字段和where的字段都在联合索引或主键内，实现。

#### where xxx is null走索引吗？

innodb规定null是最小的值。null数据量少时is null走索引，is not null不走索引；null数据量多时is not null 和!=走索引，is null不走索引

#### mysql的锁机制有哪些？和B+树的结合？锁的退化？MVCC实现原理？undo log什么时候会被删？

共享（读）/ 排它（写）锁

记录锁（行锁）、间隙锁、临键锁都属于排它锁

间隙锁是封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。1、间隙锁只有在事务隔离级别RR中才会产生；2、唯一索引只有锁住多条记录或者一条不存在的记录时，才会产生间隙锁，指定给某条存在的记录加锁时只会加记录锁，不会产生间隙锁；3、普通索引不管是锁住单条还是多条记录，都会产生间隙锁；4、间隙锁会封锁该条记录相邻两个键之间的空白区域，防止其它事务在这个区域内插入、修改、删除数据，防止出现幻读。https://zhuanlan.zhihu.com/p/48269420

乐观/悲观锁

乐观锁：假设每次拿数据别人都不会修改，不上锁，只在更新时判断一下在此期间别人有没有更改，通过版本号机制和CAS实现，适用于写少场景。悲观锁：假设每次拿数据别人都会修改，每次都上锁，适用于多写场景。

锁都是加在索引而非数据上，基本原则：

1. 加锁的基本单位是next key lock
2. 查找到访问的对象会加锁
3. 对于查询等值唯一索引的数据加锁，会退化成行锁
4. 对于查询等值非唯一索引的数据加锁，当向右扫描到第一个不符合索引的数据时，会退化成间隙锁
5. 对于范围查找唯一索引，会访问到不满足条件的第一个值位置

innodb的RR隔离级别下，使用MVCC(多版本并发控制)+临键锁解决幻读问题。https://blog.csdn.net/SIESTA030/article/details/123113437，MVCC只在RC和RR级别工作，实现原理：事务版本号+表的隐藏列+undo log+read view

生成read view的时刻记录几个全局属性：活跃（未提交）事务ID列表trx_list、trx_list中最小的ID up_limit_id、尚未分配的下一个事务ID low_limit_id、创建这个read view的事务ID creator_trx_id

- 若当前事务读到的数据事务ID = creator_trx_id，表明在访问事务自己修改过的记录，因此可见
- 若当前事务读到的数据事务ID < up_limit_id，表明后续已提交的事务没有改变该数据，因此可见
- 若数据事务ID >= low_limit_id，表明在当前事务创建read view之后有更改，不可见，需要去undo log里找数据的不在trx_list的历史版本
- 若数据事务ID介于up_limit_id和low_limit_id之间：
  - 若数据事务ID不在trx_list内，可见
  - 若数据事务ID在trx_list内，不可见，去undo log中回溯上一个不在trx_list的版本

undo log删除：异步的purge线程，当undo log的id小于up_limit_id，表明不会有事务需要回滚到这个版本，可以删除。

RR级别事务第一次读创建read view，之后用同一个，RC级别事务每次读都创建read view

#### mysql有哪些日志？

重做日志（redo）、**回滚日志（undo）**、二进制日志（binlog）、错误日志、**慢查询日志**、一般查询日志、中继日志。

#### 几种join的区别？

- left join：返回包括左表的所有记录和右表中连接字段相等的记录
- right join：返回包括右表的所有记录和左表中连接字段相等的记录
- inner join：只返回两个表中连接字段相等的记录
- full join：返回左右表中所有的记录和左右表中连接字段相等的记录
- cross join：笛卡尔积

#### 范式

https://blog.csdn.net/Rex_WUST/article/details/88392536

- 1NF：属性不可分
- 2NF：消除非主属性对码的部分函数依赖
- 3NF：消除非主属性对码的传递函数依赖
- BCNF：消除主属性对码的部分和传递函数依赖
- 4NF：消除非平凡且非函数依赖的多值依赖
- 5NF：消除不是由候选码所蕴含的连接依赖 

#### 怎么优化查询？

- 使用索引
- 优化查询语句（只返回必要的行和列，满足最左前缀匹配，分解为多个小的单表子查询减少锁竞争）
- 优化数据库（分表（垂直、水平，myisam引擎下可用merge存储引擎），分库（单库存储空间不足）， 创建中间表）

ps：单表全是数据字型的保持在800万条记录以下, 有字符型的单表保持在500万以下 

#### 如何保证幂等性

https://blog.csdn.net/wanglei303707/article/details/88298211?from=singlemessage

https://my.oschina.net/huangweiindex/blog/1843927

用Redis实现：分布式锁、token令牌等。

#### sql语句查询过程？

连接器——缓存——分析器——优化器——执行器

- 缓存生效：sql语句完全一致，没有不确定的值（now()函数等），非系统表（mysql, information_schema, performance_schema），表未更改
- 分析器：词法分析、语法分析、语义分析
  - 词法分析：把输入转化成一个个Token。其中Token中包含Keyword（也称symbol）和非Keyword，每个关键字都有一个16位的整数对应，而非关键字统一用ident表示
  - 语法分析：基于Bison生成语法树，操作符在父结点，字段和数值在子结点排列
- 优化器：自动修改sql语句使其命中索引，剪枝语法树中的冗余条件

#### redis有哪些对象和数据结构？

对象：字符串、列表、哈希、集合、有序集合

数据结构：简单动态字符串（SDS）、链表、字典、跳跃表、整数集合、压缩列表。

#### redis的应用场景？

计数器、缓存、查找表（DNS）、MQ、分布式锁（如果key不存在则set key，返回1；否则不做任何动作，返回0。基于单线程redis的分布式锁可保证原子操作）

#### redis字典、跳表的底层

字典：哈希表，使用链表保存哈希冲突，字典中包含两个哈希表，方便rehash，扩容时将其中一个哈希表上的键值对rehash到另一个上，完成之后释放空间并交换两个哈希表。

跳表：每一层都是有序链表，通过类似多级索引的机制实现对原始链表O(log(n))的查找，比AVL和红黑树更适合做范围查找，插入和删除简便，内存灵活。

#### redis持久化的两种方式和区别？

快照（RDB）和追加（AOF）。

RDB：将某个时间点的所有数据存到硬盘，简洁的单文件，fork出子进程做备份，性能好，启动速度快，但容易造成数据丢失，持久化速度慢。

AOF：记录每一个服务器收到的写操作，append到AOF文件的末尾，比RDB可靠，文件大时后台重写很安全，但文件大小比RDB大，某些情况下速度可能比RDB慢。

#### redis的过期键删除策略？

定时删除：定时器，键过期时立即删除，节省内存，占用CPU。

惰性删除：每次获取键时检查ttl，如果过期则删除，节省CPU，占用内存。

定期删除：每隔一段时间检查数据库，删除过期键，由算法决定检查多少个数据库及删除多少键，时间间隔小时占用CPU，大时占用内存。

#### redis的缓存淘汰策略？缓存穿透、击穿、雪崩？

https://blog.csdn.net/admans/article/details/123971680

**缓存淘汰策略**

1）是对所有key，还是对设置了过期时间的key
2）是随机删除，全部删除，还是用LRU或者LFU删除

最常用： allkeys-lru，被淘汰的冷数据如果又要再次被访问，则可以通过业务逻辑代码重新读入缓存中

**缓存穿透**

key对应的数据并不存在， 缓存和数据库中都查不到，海量请求把数据库打崩

解决：对空值缓存（过期时间短）、设置可以访问名单 、布隆过滤器 （多个哈希判断元素是否存在集合中 ）、实时监控 （缓存命中率急速下降设为黑名单）

**缓存击穿**

key对应的数据存在，但缓存过期，单个key的高并发访问打崩数据库

解决：预先设置热门数据并延长缓存过期时间，实时调整，热点key永不过期

**缓存雪崩**

大量key缓存过期，高并发访问打崩数据库

解决：多级缓存（nginx缓存+redis缓存+其他缓存）、设置过期标志更新缓存、将缓存时间分散（防止同时过期）、使用锁或队列机制（控制请求量，不适用高并发）

#### 存储过程

使用SQL语句和流程控制语句编写，经编译优化后存储在数据服务器端的数据库中，使用时调用即可。

和函数的区别区别：

- 函数必须返回单个值，存储过程可以返回多个值或没有返回值
- 函数可以被放置在select语句中，存储过程不行

#### 视图

从一个或多个表导出的虚拟表，内容由查询定义，具有普通表的结构，但是不实现数据存储。

作用：

- 简化操作，把经常用的数据定义为视图
- 安全性，用户只能查询和修改能看到的数据
- 逻辑独立性，屏蔽真实表结构带来的影响



# 操作系统

#### 线程vs进程

- 同：都具有就绪、阻塞、执行3种基本态和状态之间的转换关系。
- 异
  1. 进程是资源分配单位，线程是CPU调度单位
  2. 进程拥有完整的资源平台，线程只独享必不可少的资源，如寄存器和栈
  3. 线程能减少并发执行的时空开销。原因：创建和终止时间更短，同一进程内的线程切换时间更短，且共享内存和文件资源，可不通过内核通信
- 线程的优缺点
  - 优点：一个进程中可以同时存在多个线程，并发执行，共享地址空间和文件等资源
  - 缺点：一个线程崩溃，所属进程的所有线程都会崩溃
- 选择
  1. 频繁创建销毁——线程
  2. 大量计算——线程
  3. 多机分布用进程，多核分布用线程
  4. *强相关处理用线程，弱相关处理用进程

#### 同一个进程下的线程可以并行（运行在不同cpu）吗？

可以，但需要借助内核

#### 进程间通信的方式及适用场景

- 方式
  1. 管道：半双工，用于亲缘关系的进程
  2. FIFO (有名管道)：提供路径名与之关联，不需要亲缘关系
  3. 信号：用于linux
  4. 信号量：用于进程间同步
  5. 消息队列：存放在内核中的消息链表
  6. 共享内存：依靠某种机制（如信号量）达到进程间的同步互斥
  7. 套接字

- 适用场景
  1. 传递信息少，发出某些行为，简洁有效——信号
  2. 有关联的进程——管道
  3. 多对多，信息量不大且操作不频繁——消息队列（内存，磁盘需用管道）
  4. 信息量大——共享内存（要考虑同步问题）
  5. 不同机器的进程通信——套接字

#### 线程间通信的方式

锁、信号、信号量。

#### 同步IO多路复用：select vs poll vs epoll、水平触发 vs 边沿触发、用户态 vs 内核态

|              |                     select (跨平台良好)                      |                poll                |                      epoll (linux特有)                       |
| :----------: | :----------------------------------------------------------: | :--------------------------------: | :----------------------------------------------------------: |
|  **fd限制**  |                             1024                             |                 无                 |                              无                              |
| **运作方式** |                             轮询                             | fd数组整体复制于用户态和内核态之间 |         使用“事件”的就绪通知方式，通过回调机制激活fd         |
|   **描述**   | 维护用来存放大量fd的数据结构，遍历判断哪个fd就绪，时间复杂度为O(n)，主要瓶颈为用户态和内核态复制开销 |     基于链表存储，支持水平触发     | 支持水平和边沿触发，就绪事件发生时调用回调函数，时间复杂度为O(1)，且通过文件映射内存加速内核空间的消息传递 |
|   **开销**   |                              大                              |                 中                 |                              小                              |

|              |                           水平触发                           |                      边沿触发                      |
| :----------: | :----------------------------------------------------------: | :------------------------------------------------: |
|   **特性**   |     信号处于水平时可一直触发，可在任意时间检查fd的就绪态     | 信号为上升沿或下降沿时触发，只有IO事件发生时才通知 |
|   **优点**   | 保证了数据的完整输出，IO操作时，只要还有数据就会一直通知<br>比边沿触发少一次系统调用开销 | 每次内核只会通知一次，减少对内核资源的浪费，效率高 |
|   **缺点**   | 只要还有数据，就会不停发生内核态切换到用户态，占用大量内河资源，效率低 |       不保证数据的完整，不能及时取出所有数据       |
| **应用场景** |               并发量大，每个连接通信的数据量大               |     每个连接实时性要求高<br>非阻塞模式的socket     |

|                            用户态                            |                            内核态                            |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 只能受限地访问内存，不允许访问外围设备（硬盘、网卡等），占用cpu的能力被剥夺，cpu资源可以被其它程序获取 | cpu可以访问内存的所有数据，包括外围设备，cpu也可以将自己从一个程序切换到另一个程序 |

 程序都是工作在用户态，但是有时候程序需要访问一些受限的数据（如从硬盘读数据，从键盘获取输入等），这是就需要切换到内核态。切换的方式一般时调用系统调用。用户态通过系统调用通知内核态，需要访问哪些受限的数据，或操作哪些受限的设备。内核态就帮助用户态完成。 

#### 孤儿进程 vs 僵尸进程

- 孤儿进程：父进程退出，子进程还在运行，称为孤儿进程，将被init进程（1号进程）收养，完成状态收集，没有什么危害（操作失误没有杀掉姑且算危害）
- 僵尸进程：使用fork创建的子进程退出，而父进程没有调用wait或waitpid获取子进程的状态信息，子进程的描述符仍然保存在系统中，ps看到的状态为Z
  - 危害：如果大量产生僵尸进程，将因为没有可用的进程号导致系统不能产生新的进程
  - 解决：kill掉父进程，使僵尸进程变为孤儿进程
  - 避免：在父进程中捕获子进程信号，并在信号处理函数中调用waitpid彻底结束子进程

#### fork, vfork, clone, exec

- fork：复制父进程的堆、栈和静态数据，采用copy on write，只有父进程或子进程执行了写操作，复制才会发生（缺页中断，os给子进程分配内存并复制父进程数据）。子进程将继承父进程中互斥锁的状态，若对锁上的互斥锁再次加锁可能导致死锁，需通过pthread_atfork函数清理锁状态
- vfork：创造出来的子进程会导致父进程挂起，共享父进程的所有内存，包括栈地址，直至子进程启动新的应用程序为止。往往在子进程中会执行exec调用，为避免不必要的拷贝，使用vfork比fork更高效
- clone：参数众多，比fork和vfork更灵活，可以定制操作
- exec：替换当前进程，不出错时不返回

#### shutdown vs close

close：关闭套接字ID，如果有其它进程共享这个套接字，其仍然可用

shutdown：切断进程共享的套接字所有连接，无视引用计数

#### 线程池

采用预创建的技术，在app启动后立即创建一定数量的线程，放入空闲队列，处于阻塞态，不消耗cpu，占用较小的内存。当任务到来后，缓冲池把任务传入空闲线程运行，根据任务数量自动创建或销毁线程。

好处：节省现场创建和销毁线程的时间，减少创建的线程个数。

适用场景：

- 单位时间内任务频繁且耗时短
- 对实时性要求高

开多少个合适：IO占比越高需要越多，CPU占比越高需要越少

1. 最佳线程数目 = (线程等待时间 + 线程CPU时间) / 线程CPU时间 * CPU核数
2. CPU密集型：N+1，IO密集型：2N+1

#### 线程的调度算法和优缺点？

|                  |                    优点                    |                             缺点                             |
| :--------------: | :----------------------------------------: | :----------------------------------------------------------: |
|    先来先服务    |            有利用CPU繁忙的作业             |                      不利于IO繁忙的作业                      |
|    短作业优先    |                                            |                    长作业的运行得不到保证                    |
|   最短剩余时间   |                                            |                                                              |
|  最高响应比优先  | 既照顾了短作业，又考虑了作业到达的先后次序 | 调度前预先计算响应比，增加系统开销（响应比=(等待时间+要求服务时间)/要求服务时间） |
|    时间片轮转    |      在给定的时间内相应所有用户的请求      |                                                              |
|   多级反馈队列   |                                            |                                                              |
| 最大最小公平算法 |                                            |                                                              |
|   电梯调度算法   |                                            |                                                              |

#### 协程是什么？与进程/线程关系？

协程是一种用户态的轻量级线程：

- 调度完全由用户控制
- 拥有自己的寄存器上下文和栈。切换时，将其保存到其他地方，切回来时恢复，基本没有内核切换的开销，可以不加锁地访问全局变量，上下文切换非常快
- 保留上一次调用时的状态，每次过程重入时，相当于进入上一次调用的状态

与进程/线程关系：

- 一个进程/线程可以有多个协程
- 进程/线程是同步机制，协程是异步

#### 两个程序逻辑地址相同，访问时如何做到独立？

每个进程维护不同的页表。

#### 自旋锁（spinlock）？和互斥锁（mutex）对比？

线程获取锁时，如果锁已被其他线程获取，将循环等待，不断判断能否成功获取锁，直到成功才退出循环。

优点：线程一直处于用户态，一直是active，不会阻塞，没有内核切换，执行速度快

缺点：

- 如果某个线程持有锁时间过长，会导致其他线程一直忙等待，消耗CPU
- 不公平的锁，无法满足等待时间最长的线程优先获取锁，存在“线程饥饿”问题

**spinlock vs mutex**：前者适用于临界区运行时间很短的场景，后者适用于锁操作频繁的场景

#### 条件变量（管程）、虚假唤醒、唤醒丢失

条件变量：用来自动阻塞一个线程，直到某情况发生，通常和互斥锁同时使用。

虚假唤醒：用条件锁时，如果用if判断，多个等待线程在满足if条件时都会被唤醒(虚假的)，但实际上条件并不满足，生产者生产出来的消费品已经被第一个线程消费了，因此需要用 while， 对条件变量的状态进行不断检查直到其满足条件。

唤醒丢失：条件变量必须搭配互斥锁使用，确保A线程的wait在B线程的signal之前，防止出现多个线程同时请求锁的竞争条件，导致唤醒丢失。

#### 死锁

若干线程竞争有限资源，且推进顺序不当，构成无限期循环等待的局面。

举例：线程A按顺序获取锁1和锁2，线程B按顺序获取锁2和锁1，当A仅获取了锁1且B仅获取了锁2时，发生死锁

4个必要条件：互斥、不可抢占、占有并保持、循环等待。

预防方法：资源一次性分配、可剥夺资源、资源有序分配。

#### 临界区(Critical section)与互斥体(Mutex)的区别

1、临界区只能用于对象在同一进程里线程间的互斥访问；互斥体可以用于对象进程间或线程间的互斥访问。
2、临界区是非内核对象，只在用户态进行锁操作，速度快；互斥体是内核对象，在核心态进行锁操作，速度慢。
3、临界区和互斥体在Windows平台都下可用；[Linux](https://so.csdn.net/so/search?q=Linux&spm=1001.2101.3001.7020)下只有互斥体可用。 

#### 缓存淘汰策略

FIFO, LFU(最不经常使用), LRU

#### 分布式CAP

- C: Consistency, 一致性

- A: Availability, 可用性
- P: Partition Tolerance, 分区容忍性

分布式系统最多只能满足其中两项

#### Nginx

高并发容器，使用多进程，一个master进程和多个wroker进程，采用异步非阻塞的方式处理请求

#### 同步vs异步、单线程异步vs多线程同步

同步：整个处理过程顺序执行，当各个过程都执行完毕，返回结果，是一种线性执行的方式，执行的流程不能跨越

异步：发送调用的指令，无需等待被调用的方法执行完毕，继续执行下面的流程，是一种并行处理的方式

|      |                  多线程同步                   |                     单线程异步（如协程）                     |
| :--: | :-------------------------------------------: | :----------------------------------------------------------: |
| 优点 | 利用更多的CPU核，编码简单，容易捕获和处理异常 |                  减少了创建和切换线程的开销                  |
| 缺点 |             创建和切换线程的开销              |                           编码复杂                           |
| 适用 |                   多核并行                    | 不涉及共享资源，或对共享资源只读<br>没有时序上的严格关系<br>IO等耗时操作 |

#### 块设备、字符设备

块设备：系统中能够随机访问固定大小数据片的设备，这些数据片就称作块，常见的有硬盘、软盘驱动器、CD-ROM驱动器、闪存等

字符设备：按照字符流的方式有序访问，如串口、键盘

#### 页表中的TLB, MMU，访存过程，读文件过程

TLB：快表，页表的cache，存储了当前最可能被访问到的页表项副本，可以快速找到虚拟地址指向的物理地址

MMU：存储管理单元，把虚拟地址转化为实际物理地址的硬件单元

访存过程：

1. 查快表，若命中则找出物理地址
2. 若快表不命中，则查页表，若命中则找出物理地址
3. 若页表不命中，发起缺页中断，从磁盘调页，修改页表

读文件过程：系统调用 -> VFS虚拟文件系统 -> page cache -> 通用块层 -> IO调度层（电梯等调度算法） -> 驱动程序 -> 磁盘（填充到page cache）

#### 中断的上半部和下半部

- 顶半部完成尽可能少的比较紧急的功能，它往往只是简单地读取寄存器中的中断状态并清除中断标志后就进行“登记中断”的工作。“登记中断”意味着将底半部处理程序挂到该设备的底半部执行队列中去。这样，顶半部执行的速度就会很快，可以服务更多的中断请求。

- 现在，中断处理工作的重心就落在了底半部的头上，它来完成中断事件的绝大多数任务。底半部几乎做了中断处理程序所有的事情，而且可以被新的中断打断，这也是底半部和顶半部的最大不同，因为顶半部往往被设计成不可中断。底半部则相对来说并不是非常紧急的，而且相对比较耗时，不在硬件中断服务程序中执行。

这里有一些经验可供借鉴：

- 如果一个任务对时间十分敏感，将其放在上半部。

- 如果一个任务和硬件有关，将其放在上半部。

- 如果一个任务要保证不被其他中断打断，将其放在上半部。

- 其他所有任务，考虑放在下半部。



# 计算机网络

#### 三次握手和四次挥手

- 三次握手：clinet发送SYN=1的请求报文（seq=x），server收到回复SYN和ACK都为1的确认报文（seq=y, ack=x+1），client收到后再次发送ACK=1的报文（ack=y+1），建立连接。

  第三次握手的原因：防止失效的连接请求到达服务器，让服务器错误打开连接。

  初始序列号如何确定：ISN随机生成算法，计时器+哈希值（与源IP和端口、目的IP和端口有关），避免被猜出序号恶意攻击

- 四次挥手：clinet发送FIN=1的报文（seq=x），进入FIN_WAIT_1状态，server收到回复ACK=1的确认报文（ack=x+1），进入CLOSE_WAIT状态，client收到后进入FIN_WAIT_2状态，此时TCP为半关闭状态，server可以向client单向传递数据。之后server向client发送FIN=1的结束请求报文（seq=y），进入LAST_ACK状态，client收到后发送ACK=1的确认报文（ack=y+1），进入TIME_WAIT状态，等待可能出现的要求重传的ACK包，server接收到确认报文后关闭连接，进入CLOSED状态，client等待2MSL（两个最大段生命周期）后，若没有收到server的ACK包，则认为已正常关闭连接，自己也进入CLOSED。

  CLOSE_WAIT原因：让server发送未传送完的数据，完毕后会主动发送FIN。

  TIME_WAIT原因：确保最后一个确认报文能够到达，如果server没收到client发来的确认报文就会重传。

#### TCP流量控制的实现、引发的死锁、如何避免

实现：由滑动窗口（连续ARQ）协议+超时重传实现，既保证了分组无差错、有序接受，也实现了流量控制，主要方式就是接收方返回的ACK中会包含自己的接收窗口大小，并且利用大小来控制发送方的传输速率。发送窗口和接收窗口不一样

死锁：发送者收到窗口为0的应答后便停止发送，等待接收者的下一个应答，但接收者发送的窗口不为0的应答丢失，发送者和接收者都在等待，产生死锁。

避免：TCP采用持续计时器，每当发送者收到0窗口应答就启动计时器，时间一到主动发送报文询问接收者的窗口大小，若仍为0则继续等待，不为0则重置窗口开始发送。

#### 服务器出现大量CLOSE_WAIT、TIME_WAIT的成因、危害及避免措施

- CLOSE_WAIT

  成因：由于死循环、等锁、下游服务响应慢等原因造成某个响应耗时过长，大量客户端等不及后进入四次挥手流程，服务器被迫进入半关闭状态

  危害：端口数量有限，太多socket处于CLOSE_WAIT占用端口导致很难建立新连接，最终导致服务器宕机

  避免：规范服务端代码，CLOSE_WAIT状态下及时主动关闭连接

- TIME_WAIT

  成因：在高并发短连接的TCP服务器上，业务处理+数据传输的时间<<TIMEWAIT超时的时间，服务器处理完请求后主动关闭连接，出现大量TIME_WAIT

  危害：并发量持续很高时，部分客户端会连接不上

  避免：编辑内核文件，打开系统的TIMEWAIT重用和快速回收

#### TCP的可靠传输定义、实现

- 定义
  - 传输的信道不产生差错
  - 保证传输数据的正确性、无差错、不丢失、不重复、按序到达
- 实现
  - 三次握手+四次挥手
  - 流量控制
  - 拥塞控制

#### 拥塞控制的方式？

慢开始

快重传：接收方在收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认；发送方只要连续收到三个重复确认就立即重传，不必等待重传计时器到期

快恢复

#### UDP和TCP的首部字段

UDP：源端口号、目的端口号、UPD总长度、校验和

TCP：源端口、目的端口、序列号、确认号、首部长度、标志位（SYN, ACK, FIN, URG等）、窗口大小、校验和、紧急指针

#### TCP带外数据？

首部中设置URG和紧急指针表示带外数据，接收方从仅有1字节的带外缓存读取。一个数据使用MSG_OOB，则最后一个字符是OOB数据，其他的是非OOB数据。如果上层应用没有及时读取缓存，后续的带外数据将覆盖它。

#### TCP粘包？怎么解决？NO_DELAY

TCP面向字节流，存在接收端一次收到发送端多条消息的情况。

解决：

- 应用层协议实现隔离
- TCP提供了强制数据立即传送的操作指令push，不等发送缓冲区满就立即发送数据段
- 优化程序设计，精简接收进程工作量，提高接收进程优先级，使其及时接收数据
- 启动NO_DELAY，关闭Nagle算法

NO_DELAY：TCP默认开启Nagle算法， 将多个即将发送的小段的用户数据，缓存并合并成一个大段数据，一次性一并发送出去 ， 优化网络 。启动NO_DELAY将禁用Nagle算法， 对于延时敏感型，同时数据传输量比较小的应用很友好，比如ssh后的会话。

#### TCP的缺点？如何使UDP变得可靠？

缺点：

- 接收方即使已收到最新数据，还是不一定能访问，新到的数据会被放在一个队列中，需要等丢失的包都重传，所有数据没有丢失才可以访问
- 发送方一旦丢包就会重发，阻塞后续的数据包，可能产生较大的瞬时延迟

让UDP可靠：

- 每个数据包增加一段位域，容纳多个确认符
- 模拟TCP的seq/ack，在确认符中定义序列号，每次收到包，把收到的包上序列号变为确认字符，发送包的时候捎带确认字符（无需额外发seq/ack包，更快）
- 如果从确认字符里发现某个包丢失，上报给应用层决定是否需要重传，以及重传时是否用新的序列号发送

已有的可靠UDP协议：RUDP, RTP, UDT

#### TCP和UDP可以占同一端口吗？

可以，二者的端口号独立

#### MOBA游戏如何实现断线重连和技能同步？

断线重连：当客户端有操作时及时发送到服务器，服务端每秒钟一定次数向所有客户端发送更新消息，如果有玩家网络延迟，服务器的帧步进不会等待

技能同步：服务器为每个玩家分配一个随机种子，然后同步给客户端，每个客户端在计算每个角色的技能时就能保证伤害一致

#### HTTP和HTTPS的区别？HTTPS建立连接过程？比HTTP慢在哪？

|             |         HTTP         |             HTTPS              |
| :---------: | :------------------: | :----------------------------: |
| 协议/安全性 | 明文，超文本传输协议 |  SSL加密传输协议，需要ca证书   |
|    端口     |          80          |              443               |
|   复杂度    |     简单，无状态     | 复杂，可进行加密传输、身份认证 |

HTTPS建立连接：非对称加密+对称加密，浏览器通过公钥A（非对称）将秘钥X（对称）传给服务器，服务器用私钥A'（非对称）解密，此后两者安全地用秘钥X传输。

中间人攻击：劫持公钥A，替换成公钥B传给浏览器，浏览器回包后再次劫持，用私钥B'解析X。解决方案：ca证书通过数字签名将公钥和私钥与网站绑定，若被调包浏览器能识别出来

为什么不只用非对称：算法耗时

比HTTP慢在哪：比TCP的3个包多了SSL握手的9个包、证书签名校验、密钥交换、应用层数据对称加解密、一致性校验

#### HTTP消息结构、重要头部字段？

请求消息：请求行、请求头、请求体

响应消息：状态行、响应头、响应体

请求头：host, keep-alive(保活时长), connection(keep-alive代表保活，close代表不保活)

响应头：status, content-length(此字段可确定报文结束), connection

#### HTTP状态码

1**：信息，服务器收到请求，需要请求者继续执行操作，如100=Continue，客户端应继续其请求

2**：成功，如200=OK，请求成功

3**：重定向，如301=Moved Permanently，永久移动，302=Found，临时移动

4**：客户端错误，如400=Bad Request，客户端语法错误，403=Forbidden，服务器理解请求客户端的请求，但是拒绝执行此请求，404=Not Found，服务器无法根据客户端的请求找到资源

5**：服务器错误，如500=Internal Server Error，服务器内部错误，502=Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

#### HTTP: GET vs POST。有其他请求方法吗？

|          |           GET           |         POST         |
| :------: | :---------------------: | :------------------: |
| 常规用途 |        获取资源         |    修改/更新资源     |
|   参数   | 暴露在url中，有长度限制 | 请求体中，无长度限制 |
|  传输层  |    产生1个TCP数据包     |   产生2个TCP数据包   |

OPTIONS：获取当前url支持的方法

HEAD：只请求页面的首部，常用于检查链接有效性

#### HTTP怎么实现长连接？HTTP和TCP保活的区别？

HTTP在首部字段设置connection: keep-alive和keep-alive: timeout=xx实现长连接

TCP保活不能代替应用层心跳保活：

- 默认间隔时间较长
- 对于连接存在但业务已经挂掉的进程无法感知
- socks代理会让TCP保活失效

#### HTTP 1.0 vs 1.1 vs 2.0

1.1：支持长连接，在一个TCP连接上可以传送多个HTTP请求和响应

2.0：协议解析采用二进制格式；多路复用；header压缩，使用encoder减少需要传输的header大小，通信双方各自缓存一份header字段表，既避免重复传输header，又减小需要传输的大小；服务端推送

#### HTTP怎么实现断点续传？

HTTP 1.1协议中定义了断点续传相关的请求头Range和响应头Content-Range字段，用Last-Modified标识文件的最后修改时间，使用ETag头放置文件的唯一标识，如MD5值。

#### ssh的过程和特点

过程：

1. 远程主机收到用户的登录请求，把公钥发给用户
2. 用户使用公钥加密登录密码并发送给远程主机
3. 远程主机用私钥解密登录密码，正确则同意登录

特点：没有ca认证，首次连接不能避免中间人攻击，之后通过相同公钥连接，不会被中间人攻击

#### 从输入url到页面加载发生了什么

1. DNS解析：本地hosts文件——本地DNS服务器——DNS缓存——请求根DNS服务器
2. TCP连接：三次握手，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络，其中每一层对收到的数据都要增加一些首/尾部信息（增加TCP首部进入传输层——增加IP首部进入网络层（路由寻址）——增加以太网首部和尾部进入链路层（ARP请求））。目的主机收到后从协议栈中由底向上升，同时去掉各层协议加上的首部
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

#### ARP请求的详细过程

同一网段：查ARP缓存，若没有发出ARP请求广播，捎带自己的IP和MAC，目的主机收到后返回ARP响应单播

不同网段：以网关为目的地之，重复如上操作

# Linux

#### 查找文件路径

which: 查看可执行文件的位置

whereis: 查看文件的位置

find: 实际搜寻硬盘查询文件名称

#### 查看文件内容

cat: 顺序完整显示

nl: 顺序完整显示并输出行号

more: 逐页显示，可往后翻页

less: 逐页显示，可往后和往前翻页

head: 只看头几行

tail: 只看末几行

tailf: 只看末几行且同步更新

#### 查看网络连接状态

netstat

#### 查看端口占用

lsof -i:端口号

#### 实时输出系统各资源占用，如进程、内存、CPU使用率及IO情况

vmstat

#### 跟踪进程中的系统调用

strace

实践：当进程卡住时，strace -p $pid定位原因

#### 替换/dir目录下所有文件的foo为bar

sed -i "s/foo/bar/g" \`grep foo -rl /dir\`

#### 打印第m行第n列

cat $filename | awk 'NR == $m' | awk '{print $n}'

sed -n "m, 1p" $filename | awk {print $n}'

#### 软链接和硬链接区别？

软链接：产生一个新文件，指向原文件的位置，类似快捷方式，可以跨文件系统，删除原文件后软链接失效

硬链接：和原文件指向相同的物理地址，不能跨文件系统，不能给目录创建硬链接，删除其中一个另一个还在

#### 查看/释放共享内存

ipcs -m

ipcrm -m $shmid

#### 监测网络流量

ifstat

#### 网络抓包

tcpdump

# 设计模式

#### 工厂模式

理解：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，使对象创建过程延迟到子类进行。

好处：

- 一个调用者想创建一个对象，只需知道名称
- 扩展性高：如果想增加产品，只需扩展工厂类
- 屏蔽产品的具体实现，调用者只关心产品的接口

# 智力题

####          8L装满水的水壶，5L和3L的空壶，每次只能倒空或倒满，如何倒出4L水？  

8 0 0

3 5 0

3 2 3

6 2 0

6 0 2

1 5 2

1 4 3

####          8个球中有1个球较重，用天平称几次可以定位到？  

2次，分为3 3 2

# 算法题